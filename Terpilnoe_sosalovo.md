0. В правом верхнем углу листа:
**_1-СП-ПОИТ-3/группа, Фамилия И.О._**
- С этим уже никак не помогу.

 1. Расшифруйте аббревиатуру DLL.
- Dynamic link library

2. Поясните понятия «раннее связывание» и «позднее связывание».
- Раннее связывание – определение адресов вызываемых функций или методов на этапе компановки (?).
- Позднее связывание – определение адресов вызываемых функций или методов в рантайме (касательно DLL – загрузка библиотеки в память, нахождение адреса функции и её вызов).

3. Как называется функция, которая является точкой входа DLL-библиотеки и в каких случаях эта функция вызывается.
- Точка входа DLL-библиотеки – DllMain(), вызывается при загрузке библиотеки с помощью LoadLibrary(), или при выгрузке с помощью FreeLibrary(). Когда система запускает или завершает процесс или поток, она вызывает функцию точки входа для каждой загруженной библиотеки DLL с помощью первого потока процесса. Eсли есть много времени - [https://learn.microsoft.com/en-us/windows/win32/dlls/dllmain](https://learn.microsoft.com/en-us/windows/win32/dlls/dllmain).

4. Какая программа создает DLL?
- Консорциум решил, что link.exe, cl.exe передаёт /LD как /DLL для link.exe, но наверное и упоминание компилятора и линкера подойдёт (не ручаюсь).

5. Для чего применется директива _EXTERN_ _“__C__”._
- Отменяется декорация имён С++ (не добавляется инфа об аргументах в изменённом имени функции) => обеспечивается совместимость с С, что позволяет использовать библиотеки не только C++ клиентам
// писать процедуры/функции без extern "C" можно, если используется C++ клиент (желательно такой же, на каком написана библиотека)).

6. Для чего экспортируются функции DLL?
/КоллокСП1: Функции DLL экспортируются для того, чтобы их можно было использовать другими программами или библиотеками.

7. Назовите 2 способа экспорта функций DLL.
- __declspec(dllexport) в коде функции, .def файл с секцией EXPORTS

8. Как называется функция загрузки DLL? Какие параметры принимает эта функция?
- ```HMODULE LoadLibrary(LPCSTR libFileName)```- надеюсь, из прототипа понятно.

9. Как называется функция выгрузки  DLL? Какие параметры принимает эта функция?
- ```BOOL FreeLibrary(HMODULE hLibModule)``` - sapienti sat.

10. Для чего применяется функция GetProcAddress? Какие параметры принимает эта функция? Что возвращает эта функция?
- ```FARPROC GetProcAddress(  [in] HMODULE hModule,  [in] LPCSTR procName)``` - для получения адреса экспортируемой из DLL функции/переменной
hModule - дескриптор модуля dll, возвращают LoadLibrary //, LoadLibraryEx, LoadPackageLibrary, GetModuleHandle
procName - имя функции или переменной.
Ретурнит адрес функции (переменной), если такая есть и экспортирована, иначе NULL.
// Касательно FARPROC - определение ```int (FAR WINAPI * FARPROC) ()``` (поверим бингу на слово, так не нашёл), если проще, то ето поинтер на функцию, которая принимает любое количество параметров.

11. Поясните выражение «DLL проецируется в адресное пространство процесса».
- Код и данные DLL загружаются в память процесса, и становятся доступными для использования этим процессом.

12. Поясните понятие «библиотека импорта».
- Статическая библиотека, содержащая информацию, необходимую для связывания вызовов функций и переменных в коде с их реализациями в DLL (нужные функции и переменные DLL загружаются в память перед исполнением программы).

13. Какая программа создает библиотеку импорта.
- link.exe (при автоматическом создании)
    
14. Расшифруйте аббревиатуру COM. Поясните смысл  термина.
- Component Object Model - платформенно-независимая распределённая объектно-ориентированная система для создания двоичных программных компонентов (dll, exe), которые могут взаимодействовать.

15. Поясните понятие «клиент-серверная архитектура приложения».
/КоллокСП1: Архитектура программного обеспечения, в которой приложение состоит из двух основных компонентов: клиента и сервера. Клиент обращается к серверу за услугами, которые тот предоставляет

16. Для чего применяется OLE32.DLL?
- Предоставляет базовую функциональность для создания объектов и их взаимодействия.
- Выступает (в цирке) посредниCOM между COM-клиентом и COM-сервером.

17. Назовите 2 типа контейнера для COM-сервера.
- In-process Container: Контейнер, который выполняется в том же процессе, что и COM-сервер (dll).
- Out-of-process Container: Контейнер, который выполняется в отдельном процессе от COM-сервера (exe).

18. Перечислите три типа COM-серверов.
- CLSCTX_INPROC_SERVER (DLL внутрипроцессный сервер; Выполнение этого компонента происходит в контексте вызывающего процесса); 
- CLSCTX_LOCAL_SERVER (EXE-сервер за границами процесса, но та том же компьютере; в пространстве другой задачи на том же компьютере (ЕХЕ-файл)); 
- СLSCTX_REMOTE_SERVER (компонент, загружаемый и выполняемый на удаленном компьютере).

19. Чем отличаются однокомпонентные сервера от многокомпонентных.
- Предоставляют 1 (одно-) или несколько (много-) типов компонентов.

20. Расшифруйте аббревиатуру GUID, поясните смысл термина.
- GUID(Globally Unique Identifier, 128bit) – реализация Microsoft стандарта идентификации UUID (Universally Unique Identifier).
- В СОМ идентификаторы GUID используются для идентификации классов компонента (CLSID), интерфейсов (IID), библиотек типов (LIBID) и категорий компонентов (CATID). 

21. Для чего используется макрос STDMETHODCALLTYPE?
- Для указания соглашения о вызове __stdcall для методов в COM-интерфейсах: (параметры справа налево, стек очищает вызываемый код)

22. Для чего используется структура HRESULT?
- Все функции OLE32.DLL (кроме AddRef и Release) возвращают значение типа HRESULT.
- В Win32 тип данных HRESULT определяется как DWORD (32-битовое целое), а возвращаемое значение этого типа содержит информацию о результате вызова функции.

23. Поясните термин «стандартный CОМ-интерфейс».
- Определён и поддерживается самой технологией COM (часть спецификации COM), обеспечивает based функциональность для работы с COM-объектами. + имеют закреплённый GUID

24. Перечислите стандартные COM-интерфейсы и их методы.
- IUnknown (base всех COM-интерфейсов): QueryInterface, AddRef, Release
- IClassFactory (интерфейс фабрики классов компонентов): CreateInstance, LockServer, + методы IUnknown
// и др.

25. Для чего применяется утилита Regsvr32?
- Для (/отмены) регистрации элементов управления OLE (в т. ч. DLL) в системном реестре Windows

26. Перечислите экспортируемые функции COM-сервера типа INPROC.
- DllCanUnloadNow(): используется ли DLL, реализующая эту функцию
- DllGetClassObject(const CLSID& clsid, const IID& iid, void** ppv): создаёт экземпляр фабрики классов, возвращает указатель на её интерфейс 
- DllInstall(BOOOOL, PCWSTR): обрабатывает установку и настройку DLL
- DllRegisterServer(): регистрирует DLL в системе (связывает GUID и путь к dll)
- DllUnregisterServer(): удаляет записи из реестра, добавленные DllRegisterServer

27. Перечислите счетчики, которые должен поддерживать COM-сервер.
- Счётчик экземпляров компонент (сколько ссылок на объект), регулируется AddRef и Release
- Счётчик "блокировок" сервера (сколько раз объект был "заблокирован" для предотвращения выгрузки его содержащего сервера при отсутствии ссылок на объект, регулируется LockServer

28. Назначение метода QueryInterface.
- запрос у COM-объекта указателя на интерфейс по IID

29. Назначение метода AddRef.
- увеличить значение счётчика обращений к объекту на 1

30. Назначение метода Release.
- уменьшить значение счётчика обращений к объекту на 1

31. Назначение метода CreateInstance.
- Создаёт экземпляр компонента, при вызове запрашивается его интерфейс по IID

32. Назначение метода ServerLock.
- "Блокировка" сервера в памяти: предотвращает выгрузку сервера при отвутствии ссылок на обхект, который он реализует (что повышает производительность при нескольких обращениях)

33. Напишите три условия при котором  DllCanUnloadNow возвращает Succeeded-значение.
- 1) Счётчик экземпляров компонент равен 0
- 2) Счётчик блокировок сервера равен 0
- 3) Нет активных вызовов методов или обработчиков событий в DLL (?)

34. Что функция DllGetClassObject возвращает последним параметром?
- Указатель на интерфейс экземпляра фабрики классов

35. Каким способом вызываются функции DllRegisterServer, DllUnregisterServer и DllInstall?
- regsvr32          - DllRegisterServer
- regsvr32 /u       - DllUnregisterServer
- regsvr32 /i       - DllInstall(true) [ok]-> DllRegisterServer
- regsvr32 /i /n    - DllInstall(true)
- regsvr32 /i /u    - DllInstall(false) [ok]-> DllUnregisterServer
- regsvr32 /i /u /n - DllInstall(false)

Источники: Э. Таненбаум - Архитекрура Компьютера, Pavel Yosifovich - Windows 10 System Programming, Part 1/2, конспект Смелова (я тогда его писал...), stackoverflow, bing
